---
title: 阻塞与非阻塞、同步与异步、Reactor与Proactor
date: 2018-03-10 17:32:28
tags: [Linux,I/O]
---
#### 同步和异步
> 同步与异步的重点在消息通知的方式上，也就是调用结果通知的方式。

- 同步：当一个同步调用发出去后，调用者要一直等待调用结果的通知后，才能进行后续的执行

- 异步：当一个异步调用发出去后，调用者不能立即得到调用结果的返回。


异步调用，要想获得结果，一般有两种方式：
1. 主动轮询异步调用的结果;
2. 被调用方通过callback来通知调用方调用结果。


#### 阻塞/非阻塞
> 阻塞与非阻塞的重点在于进/线程等待消息时候的行为，也就是在等待消息的时候，当前进/线程是挂起状态，还是非挂起状态。

- 阻塞:阻塞调用在发出去后，在消息返回之前，当前进/线程会被挂起，直到有消息返回，当前进/线程才会被激活.

- 非阻塞:非阻塞调用在发出去后，不会阻塞当前进/线程，而会立即返回。


> 在处理IO的时候，阻塞和非阻塞都是同步IO。
> 只有使用了特殊的API才是异步IO


同步：IO复用（select/poll/epoll）：阻塞和非阻塞

异步：Linux（AIO）、Windows(IOCP)、.NET(BeginInvoke/EndInvoke)

```
为什么epoll是阻塞的，NginX是非阻塞的?

nginx的异步并不是指epoll的wait是异步的,而是指对于每个socketfd来说,它的handle是异步的。
```

#### Reactor/Proactor

区别内核和用户程序来说

标准定义:两种I/O多路复用模式：Reactor和Proactor

一般地,I/O多路复用机制都依赖于一个事件多路分离器(Event Demultiplexer)。分离器对象可将来自事件源的I/O事件分离出来，并分发到对应的read/write事件处理器(Event Handler)。开发人员预先注册需要处理的事件及其事件处理器（或回调函数）；事件分离器负责将请求事件传递给事件处理器。

**两个与事件分离器有关的模式是Reactor和Proactor。Reactor模式采用同步IO，而Proactor采用异步IO。**


- Reactor

    - 应用程序注册读就需事件和相关联的事件处理器。

    - 事件分离器等待事件的发生。

    - 当发生读就需事件的时候，事件分离器调用第一步注册的事件处理器。

    - 事件处理器首先执行实际的读取操作，然后根据读取到的内容进行进一步的处理。

- Proactor

    - 应用程序初始化一个异步读取操作，然后注册相应的事件处理器，此时事件处理器不关注读取就绪事件，而是关注读取完成事件，这是区别于Reactor的关键。

    - 事件分离器等待读取操作完成事件。

    - 在事件分离器等待读取操作完成的时候，操作系统调用内核线程完成读取操作，并将读取的内容放入用户传递过来的缓存区中。这也是区别于Reactor的一点，在Proactor中，应用程序需要传递缓存区。

    - 事件分离器捕获到读取完成事件后，激活应用程序注册的事件处理器，事件处理器直接从缓存区读取数据，而不需要进行实际的读取操作。

从上面可以看出，Reactor和Proactor模式的主要区别就是真正的读取和写入操作是有谁来完成的，Reactor中需要应用程序自己读取或者写入数据，而Proactor模式中，应用程序不需要进行实际的读写过程，操作系统会读取缓存区或者写入缓存区到真正的IO设备。
